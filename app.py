
import os
import io
import sys
import csv
import json
import base64
import math
import time
import uuid
import hashlib
import datetime as dt
from typing import List, Tuple, Optional, Dict, Any

from flask import (
    Flask, request, jsonify, redirect, url_for, Response,
    send_file, render_template_string
)
from flask_login import (
    LoginManager, login_user, login_required, logout_user, UserMixin, current_user
)

# ---------- Optional dependencies ----------
try:
    import cv2  # type: ignore
except Exception:
    cv2 = None

try:
    from deepface import DeepFace  # type: ignore
except Exception:
    DeepFace = None

try:
    import openpyxl  # type: ignore
except Exception:
    openpyxl = None

try:
    from reportlab.pdfgen import canvas  # type: ignore
    from reportlab.lib.pagesizes import A4  # type: ignore
except Exception:
    canvas = None
    A4 = None

# ---------- Database backend (PostgreSQL if DATABASE_URL is set, else SQLite) ----------
DATABASE_URL = os.getenv("DATABASE_URL", "").strip()

if DATABASE_URL:
    import psycopg2
    from psycopg2.extras import DictCursor
    _DB_IS_POSTGRES = True
else:
    import sqlite3
    _DB_IS_POSTGRES = False

def get_conn():
    if _DB_IS_POSTGRES:
        return psycopg2.connect(DATABASE_URL)
    else:
        return sqlite3.connect("attendance.db", detect_types=sqlite3.PARSE_DECLTYPES | sqlite3.PARSE_COLNAMES)

def exec_sql(conn, q: str, params: Tuple = (), dict_rows: bool = False):
    if _DB_IS_POSTGRES:
        cur = conn.cursor(cursor_factory=DictCursor) if dict_rows else conn.cursor()
        cur.execute(q, params)
        try:
            rows = cur.fetchall()
        except Exception:
            rows = []
        return rows, cur
    else:
        conn.row_factory = sqlite3.Row if dict_rows else None
        cur = conn.cursor()
        cur.execute(q, params)
        try:
            rows = cur.fetchall()
        except Exception:
            rows = []
        return rows, cur

def qmarks(n: int) -> str:
    return ",".join(["%s" if _DB_IS_POSTGRES else "?" for _ in range(n)])

def placeholder() -> str:
    return "%s" if _DB_IS_POSTGRES else "?"

# ---------- App & Auth ----------
app = Flask(__name__)
app.secret_key = os.getenv("FLASK_SECRET_KEY", "dev-secret-key")

login_manager = LoginManager(app)
login_manager.login_view = "login"

class User(UserMixin):
    def __init__(self, user_id: int, username: str, password_hash: str):
        self.id = str(user_id)
        self.username = username
        self.password_hash = password_hash

def password_hash(pw: str) -> str:
    return hashlib.sha256(pw.encode("utf-8")).hexdigest()

@login_manager.user_loader
def load_user(user_id: str) -> Optional[User]:
    conn = get_conn()
    try:
        q = "SELECT id, username, password_hash FROM users WHERE id = " + ("%s" if _DB_IS_POSTGRES else "?")
        rows, _ = exec_sql(conn, q, (int(user_id),))
        if rows:
            row = rows[0]
            return User(row[0], row[1], row[2])
        return None
    finally:
        conn.close()

# ---------- Storage ----------
DATA_DIR = os.path.abspath(os.getenv("DATA_DIR", "data"))
IMAGES_DIR = os.path.join(DATA_DIR, "images")
os.makedirs(IMAGES_DIR, exist_ok=True)

# ---------- DDL ----------
DDL_USERS = """
CREATE TABLE IF NOT EXISTS users (
    id INTEGER PRIMARY KEY {auto},
    username TEXT UNIQUE NOT NULL,
    password_hash TEXT NOT NULL
);
""".format(auto="GENERATED BY DEFAULT AS IDENTITY" if _DB_IS_POSTGRES else "AUTOINCREMENT")

DDL_STUDENTS = """
CREATE TABLE IF NOT EXISTS students (
    roll_number TEXT PRIMARY KEY,
    name TEXT NOT NULL,
    class_name TEXT NOT NULL,
    image_path TEXT
);
"""

DDL_CLASSES = """
CREATE TABLE IF NOT EXISTS classes (
    name TEXT PRIMARY KEY
);
"""

DDL_TEACHERS = """
CREATE TABLE IF NOT EXISTS teachers (
    id INTEGER PRIMARY KEY {auto},
    name TEXT NOT NULL,
    email TEXT UNIQUE
);
""".format(auto="GENERATED BY DEFAULT AS IDENTITY" if _DB_IS_POSTGRES else "AUTOINCREMENT")

DDL_CLASS_TEACHERS = """
CREATE TABLE IF NOT EXISTS class_teachers (
    class_name TEXT NOT NULL,
    teacher_id INTEGER NOT NULL,
    PRIMARY KEY (class_name, teacher_id),
    FOREIGN KEY (class_name) REFERENCES classes(name),
    FOREIGN KEY (teacher_id) REFERENCES teachers(id)
);
"""

DDL_ATTENDANCE = """
CREATE TABLE IF NOT EXISTS attendance (
    id INTEGER PRIMARY KEY {auto},
    student_roll_number TEXT NOT NULL,
    class_name TEXT NOT NULL,
    timestamp TIMESTAMP NOT NULL,
    FOREIGN KEY(student_roll_number) REFERENCES students(roll_number)
);
""".format(auto="GENERATED BY DEFAULT AS IDENTITY" if _DB_IS_POSTGRES else "AUTOINCREMENT")

def setup_database():
    conn = get_conn()
    try:
        for ddl in (DDL_USERS, DDL_STUDENTS, DDL_CLASSES, DDL_TEACHERS, DDL_CLASS_TEACHERS, DDL_ATTENDANCE):
            exec_sql(conn, ddl); conn.commit()
        # seed admin
        rows, _ = exec_sql(conn, "SELECT id FROM users WHERE username = " + placeholder(), ("admin",))
        if not rows:
            exec_sql(conn, "INSERT INTO users (username, password_hash) VALUES (" + qmarks(2) + ")", ("admin", password_hash("admin123"))); conn.commit()
        # seed class
        rows, _ = exec_sql(conn, "SELECT name FROM classes WHERE name = " + placeholder(), ("ClassA",))
        if not rows:
            exec_sql(conn, "INSERT INTO classes (name) VALUES (" + placeholder() + ")", ("ClassA",)); conn.commit()
    finally:
        conn.close()

# ---------- Embeddings ----------
student_embeddings: Dict[str, Any] = {}

def embedding_available() -> bool:
    return DeepFace is not None

def build_student_embeddings():
    student_embeddings.clear()
    if not embedding_available():
        print("[INFO] DeepFace not available; skipping embeddings.")
        return
    conn = get_conn()
    try:
        rows, _ = exec_sql(conn, "SELECT roll_number, image_path FROM students", ())
        for r in rows:
            roll, img = r[0], r[1]
            if img and os.path.exists(img):
                try:
                    rep = DeepFace.represent(img_path=img, model_name="Facenet")
                    vec = rep[0]["embedding"] if isinstance(rep, list) and isinstance(rep[0], dict) else rep
                    if vec is not None:
                        student_embeddings[roll] = vec
                except Exception as e:
                    print(f"[WARN] embed failed for {img}: {e}", file=sys.stderr)
    finally:
        conn.close()

def cosine_sim(a, b):
    if not a or not b or len(a) != len(b):
        return -1.0
    num = sum(x*y for x, y in zip(a, b))
    da = math.sqrt(sum(x*x for x in a))
    db = math.sqrt(sum(y*y for y in b))
    if da == 0 or db == 0:
        return -1.0
    return num / (da * db)

def recognize_vector(vec, threshold: float = 0.35):
    best_roll, best_score = None, -1.0
    for roll, emb in student_embeddings.items():
        score = cosine_sim(vec, emb)
        if score > best_score:
            best_score, best_roll = score, roll
    if best_roll is None:
        return None, 0.0
    return (best_roll, best_score if best_score >= (1 - threshold) else None)

# ---------- UI ----------
INDEX_HTML = """
<!doctype html>
<title>Attendance System</title>
<h2>Welcome, {{ username }}</h2>
<ul>
  <li><a href="/camera_ui">Browser Camera UI</a></li>
</ul>
<p>API endpoints:</p>
<ul>
  <li>Students: GET/POST /students, PUT/DELETE /students/&lt;roll&gt;, POST /students/&lt;roll&gt;/upload_image</li>
  <li>Classes: GET/POST /classes, DELETE /classes/&lt;name&gt;</li>
  <li>Teachers: GET/POST /teachers, POST /classes/assign_teacher</li>
  <li>Attendance: POST /attendance</li>
  <li>Summary: GET /summary?date=YYYY-MM-DD&class=ClassA</li>
  <li>Exports: /export/csv, /export/xlsx, /export/pdf</li>
  <li>Video: GET /video_feed (IP camera or local only)</li>
  <li>Embeddings: GET /rebuild_embeddings</li>
</ul>
"""

@app.route("/")
@login_required
def index():
    return render_template_string(INDEX_HTML, username=current_user.username)

CAMERA_HTML = """
<!doctype html>
<title>Camera UI</title>
<style> body { font-family: system-ui, sans-serif; } #log { white-space: pre; } </style>
<h2>Browser Camera</h2>
<p>This uses your browser camera (works on Render). Click "Start" then "Recognize" to send frames to the server.</p>
<video id="video" width="480" height="360" autoplay muted playsinline></video><br>
<canvas id="canvas" width="480" height="360" style="display:none"></canvas>
<br>
<button id="start">Start Camera</button>
<button id="shot">Recognize</button>
<p id="status"></p>
<pre id="log"></pre>
<script>
const video = document.getElementById('video');
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const statusEl = document.getElementById('status');
const logEl = document.getElementById('log');

document.getElementById('start').onclick = async () => {
  try {
    const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: false });
    video.srcObject = stream;
    statusEl.textContent = 'Camera started';
  } catch (e) {
    statusEl.textContent = 'Camera error: ' + e;
  }
};

document.getElementById('shot').onclick = async () => {
  ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
  const b64 = canvas.toDataURL('image/jpeg'); // data:image/jpeg;base64,XXXX
  statusEl.textContent = 'Sending...';
  try {
    const resp = await fetch('/recognize', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ image_base64: b64 })
    });
    const data = await resp.json();
    logEl.textContent = JSON.stringify(data, null, 2);
    statusEl.textContent = 'Done';
  } catch (e) {
    statusEl.textContent = 'Request error: ' + e;
  }
};
</script>
"""

@app.route("/camera_ui")
@login_required
def camera_ui():
    return render_template_string(CAMERA_HTML)

# ---------- Auth ----------
LOGIN_HTML = """
<!doctype html>
<title>Login</title>
<h2>Login</h2>
<form method="post">
  <label>Username <input name="username" required></label><br>
  <label>Password <input type="password" name="password" required></label><br>
  <button type="submit">Login</button>
</form>
{% if error %}<p style="color:red">{{ error }}</p>{% endif %}
"""

@app.route("/login", methods=["GET", "POST"])
def login():
    error = None
    if request.method == "POST":
        username = request.form.get("username","").strip()
        password = request.form.get("password","")
        conn = get_conn()
        try:
            rows, _ = exec_sql(conn, "SELECT id, username, password_hash FROM users WHERE username = " + placeholder(), (username,))
            if rows:
                uid, uname, pw_hash = rows[0][0], rows[0][1], rows[0][2]
                if password_hash(password) == pw_hash:
                    login_user(User(uid, uname, pw_hash))
                    return redirect(url_for("index"))
            error = "Invalid credentials"
        finally:
            conn.close()
    return render_template_string(LOGIN_HTML, error=error)

@app.route("/logout")
@login_required
def logout():
    logout_user()
    return redirect(url_for("login"))

# ---------- Students CRUD (same as before) ----------
@app.route("/students", methods=["GET"])
@login_required
def list_students():
    conn = get_conn()
    try:
        rows, _ = exec_sql(conn, "SELECT roll_number, name, class_name, image_path FROM students ORDER BY class_name, roll_number", (), True)
        return jsonify([dict(r) for r in rows])
    finally:
        conn.close()

@app.route("/students", methods=["POST"])
@login_required
def create_student():
    data = request.get_json(silent=True) or {}
    rn = (data.get("roll_number") or "").strip()
    nm = (data.get("name") or "").strip()
    cls = (data.get("class_name") or "").strip()
    img = (data.get("image_path") or "").strip() or None
    if not rn or not nm or not cls:
        return jsonify(error="roll_number, name, class_name are required"), 400
    conn = get_conn()
    try:
        if _DB_IS_POSTGRES:
            q = "INSERT INTO students (roll_number, name, class_name, image_path) VALUES (" + qmarks(4) + ") ON CONFLICT (roll_number) DO UPDATE SET name=EXCLUDED.name, class_name=EXCLUDED.class_name, image_path=EXCLUDED.image_path"
        else:
            q = "INSERT OR REPLACE INTO students (roll_number, name, class_name, image_path) VALUES (" + qmarks(4) + ")"
        exec_sql(conn, q, (rn, nm, cls, img)); conn.commit()
    finally:
        conn.close()
    return jsonify(ok=True)

@app.route("/students/<roll>", methods=["PUT"])
@login_required
def update_student(roll):
    data = request.get_json(silent=True) or {}
    nm = data.get("name")
    cls = data.get("class_name")
    img = data.get("image_path")
    sets, params = [], []
    if nm is not None:
        sets.append("name = " + placeholder()); params.append(nm)
    if cls is not None:
        sets.append("class_name = " + placeholder()); params.append(cls)
    if img is not None:
        sets.append("image_path = " + placeholder()); params.append(img if img else None)
    if not sets:
        return jsonify(error="No changes"), 400
    params.append(roll)
    q = "UPDATE students SET " + ", ".join(sets) + " WHERE roll_number = " + placeholder()
    conn = get_conn()
    try:
        exec_sql(conn, q, tuple(params)); conn.commit()
    finally:
        conn.close()
    return jsonify(ok=True)

@app.route("/students/<roll>", methods=["DELETE"])
@login_required
def delete_student(roll):
    conn = get_conn()
    try:
        exec_sql(conn, "DELETE FROM students WHERE roll_number = " + placeholder(), (roll,)); conn.commit()
    finally:
        conn.close()
    student_embeddings.pop(roll, None)
    return jsonify(ok=True)

@app.route("/students/<roll>/upload_image", methods=["POST"])
@login_required
def upload_student_image(roll):
    if "image" not in request.files:
        return jsonify(error="No file part 'image'"), 400
    f = request.files["image"]
    if not f.filename:
        return jsonify(error="No selected file"), 400
    ext = os.path.splitext(f.filename)[1].lower() or ".jpg"
    out_path = os.path.join(IMAGES_DIR, f"{roll}{ext}")
    f.save(out_path)
    conn = get_conn()
    try:
        exec_sql(conn, "UPDATE students SET image_path = " + placeholder() + " WHERE roll_number = " + placeholder(), (out_path, roll)); conn.commit()
    finally:
        conn.close()
    if embedding_available():
        try:
            rep = DeepFace.represent(img_path=out_path, model_name="Facenet")
            vec = rep[0]["embedding"] if isinstance(rep, list) and isinstance(rep[0], dict) else rep
            if vec is not None:
                student_embeddings[roll] = vec
        except Exception as e:
            print(f"[WARN] embed failed for {out_path}: {e}", file=sys.stderr)
    return jsonify(ok=True, image_path=out_path)

# ---------- Classes & Teachers ----------
@app.route("/classes", methods=["GET"])
@login_required
def list_classes():
    conn = get_conn()
    try:
        rows, _ = exec_sql(conn, "SELECT name FROM classes ORDER BY name", (), True)
        return jsonify([r["name"] for r in rows])
    finally:
        conn.close()

@app.route("/classes", methods=["POST"])
@login_required
def create_class():
    data = request.get_json(silent=True) or {}
    name = (data.get("name") or "").strip()
    if not name:
        return jsonify(error="name required"), 400
    conn = get_conn()
    try:
        if _DB_IS_POSTGRES:
            q = "INSERT INTO classes (name) VALUES (" + placeholder() + ") ON CONFLICT (name) DO NOTHING"
        else:
            q = "INSERT OR IGNORE INTO classes (name) VALUES (" + placeholder() + ")"
        exec_sql(conn, q, (name,)); conn.commit()
    finally:
        conn.close()
    return jsonify(ok=True)

@app.route("/classes/<name>", methods=["DELETE"])
@login_required
def delete_class(name):
    conn = get_conn()
    try:
        exec_sql(conn, "DELETE FROM classes WHERE name = " + placeholder(), (name,)); conn.commit()
    finally:
        conn.close()
    return jsonify(ok=True)

@app.route("/teachers", methods=["GET"])
@login_required
def list_teachers():
    conn = get_conn()
    try:
        rows, _ = exec_sql(conn, "SELECT id, name, email FROM teachers ORDER BY name", (), True)
        return jsonify([dict(r) for r in rows])
    finally:
        conn.close()

@app.route("/teachers", methods=["POST"])
@login_required
def create_teacher():
    data = request.get_json(silent=True) or {}
    name = (data.get("name") or "").strip()
    email = (data.get("email") or "").strip() or None
    if not name:
        return jsonify(error="name required"), 400
    conn = get_conn()
    try:
        exec_sql(conn, "INSERT INTO teachers (name, email) VALUES (" + qmarks(2) + ")", (name, email)); conn.commit()
    finally:
        conn.close()
    return jsonify(ok=True)

@app.route("/classes/assign_teacher", methods=["POST"])
@login_required
def assign_teacher():
    data = request.get_json(silent=True) or {}
    class_name = (data.get("class_name") or "").strip()
    teacher_id = data.get("teacher_id")
    if not class_name or teacher_id is None:
        return jsonify(error="class_name and teacher_id required"), 400
    conn = get_conn()
    try:
        q = "INSERT INTO class_teachers (class_name, teacher_id) VALUES (" + qmarks(2) + ")"
        if _DB_IS_POSTGRES:
            q += " ON CONFLICT DO NOTHING"
        else:
            q = "INSERT OR IGNORE INTO class_teachers (class_name, teacher_id) VALUES (" + qmarks(2) + ")"
        exec_sql(conn, q, (class_name, int(teacher_id))); conn.commit()
    finally:
        conn.close()
    return jsonify(ok=True)

# ---------- Attendance ----------
@app.route("/attendance", methods=["POST"])
@login_required
def mark_attendance():
    data = request.get_json(silent=True) or {}
    rn = (data.get("student_roll_number") or "").strip()
    cls = (data.get("class_name") or "").strip()
    ts = data.get("timestamp")
    try:
        ts_dt = dt.datetime.fromisoformat(ts) if ts else dt.datetime.now()
    except Exception:
        return jsonify(error="timestamp must be ISO 8601"), 400
    if not rn or not cls:
        return jsonify(error="student_roll_number and class_name are required"), 400
    conn = get_conn()
    try:
        exec_sql(conn, "INSERT INTO attendance (student_roll_number, class_name, timestamp) VALUES (" + qmarks(3) + ")", (rn, cls, ts_dt)); conn.commit()
    finally:
        conn.close()
    return jsonify(ok=True)

# ---------- Summary ----------
@app.route("/summary", methods=["GET"])
@login_required
def summary():
    selected_date = request.args.get("date")
    allowed_classes = request.args.getlist("class")
    q = (
        "SELECT s.roll_number, s.name, a.class_name, DATE(a.timestamp) AS day "
        "FROM attendance a JOIN students s ON s.roll_number = a.student_roll_number"
    )
    cond, params = [], []
    if selected_date:
        cond.append("DATE(a.timestamp) = " + placeholder()); params.append(selected_date)
    if allowed_classes:
        cond.append("a.class_name IN (" + qmarks(len(allowed_classes)) + ")"); params.extend(allowed_classes)
    if cond:
        q += " WHERE " + " AND ".join(cond)
    q += " ORDER BY a.timestamp DESC"

    conn = get_conn()
    try:
        rows, _ = exec_sql(conn, q, tuple(params), True)
        records = [dict(r) for r in rows]
        total_students = present_today = absent_today = 0
        if allowed_classes:
            q_total = "SELECT COUNT(*) FROM students WHERE class_name IN (" + qmarks(len(allowed_classes)) + ")"
            rows_total, _ = exec_sql(conn, q_total, tuple(allowed_classes))
            total_students = rows_total[0][0] if rows_total else 0
            if selected_date:
                q_present = (
                    "SELECT COUNT(DISTINCT student_roll_number) FROM attendance "
                    "WHERE DATE(timestamp) = " + placeholder() + " AND class_name IN (" + qmarks(len(allowed_classes)) + ")"
                )
                rows_present, _ = exec_sql(conn, q_present, (selected_date, *allowed_classes))
                present_today = rows_present[0][0] if rows_present else 0
                absent_today = max(total_students - present_today, 0)
        return jsonify({"filters": {"date": selected_date, "classes": allowed_classes},"rows": records,"totals": {"total_students": total_students,"present": present_today,"absent": absent_today}})
    finally:
        conn.close()

# ---------- Video & Capture ----------
IP_CAM_URL = os.getenv("IP_CAM_URL", "").strip()  # e.g., rtsp://user:pass@host/stream

def gen_frames(source=0):
    if cv2 is None:
        return
    cap = cv2.VideoCapture(source)
    if not cap.isOpened():
        return
    try:
        while True:
            ok, frame = cap.read()
            if not ok:
                break
            ok, buf = cv2.imencode(".jpg", frame)
            if not ok:
                continue
            jpg = buf.tobytes()
            yield (b"--frame\r\nContent-Type: image/jpeg\r\n\r\n" + jpg + b"\r\n")
    finally:
        cap.release()

@app.route("/video_feed")
@login_required
def video_feed():
    # On Render: works only if IP_CAM_URL points to a reachable IP camera.
    if cv2 is None:
        return jsonify(error="OpenCV not available"), 503
    if IP_CAM_URL:
        source = IP_CAM_URL
    else:
        # Local camera only works when you run the app on a machine with /dev/video0
        source = int(request.args.get("camera_index", 0))
    return Response(gen_frames(source), mimetype="multipart/x-mixed-replace; boundary=frame")

@app.route("/capture", methods=["POST"])
@login_required
def capture():
    if cv2 is None:
        return jsonify(error="OpenCV not available"), 503
    source = IP_CAM_URL if IP_CAM_URL else int((request.get_json(silent=True) or {}).get("camera_index", 0))
    cap = cv2.VideoCapture(source)
    if not cap.isOpened():
        return jsonify(error="Cannot open camera source"), 500
    ok, frame = cap.read()
    cap.release()
    if not ok:
        return jsonify(error="Failed to capture"), 500
    _, buf = cv2.imencode(".jpg", frame)
    return Response(buf.tobytes(), mimetype="image/jpeg")

# ---------- Recognition (multipart OR base64 JSON) ----------
@app.route("/recognize", methods=["POST"])
@login_required
def recognize():
    if not embedding_available():
        return jsonify(error="DeepFace not available"), 503

    image_path = None
    temp_file = None
    # Case 1: multipart upload
    if "image" in request.files and request.files["image"].filename:
        f = request.files["image"]
        temp_file = os.path.join(IMAGES_DIR, f"tmp_{uuid.uuid4().hex}.jpg")
        f.save(temp_file)
        image_path = temp_file
    else:
        # Case 2: JSON base64 (data URL or raw b64)
        data = request.get_json(silent=True) or {}
        b64 = data.get("image_base64")
        if not b64:
            return jsonify(error="Provide multipart 'image' or JSON 'image_base64'"), 400
        if b64.startswith("data:image"):
            b64 = b64.split(",", 1)[1]
        try:
            img_bytes = base64.b64decode(b64)
        except Exception:
            return jsonify(error="Invalid base64"), 400
        temp_file = os.path.join(IMAGES_DIR, f"tmp_{uuid.uuid4().hex}.jpg")
        with open(temp_file, "wb") as fh:
            fh.write(img_bytes)
        image_path = temp_file

    try:
        rep = DeepFace.represent(img_path=image_path, model_name="Facenet")
        vec = rep[0]["embedding"] if isinstance(rep, list) and isinstance(rep[0], dict) else rep
        if not vec:
            return jsonify(match=None)
        roll, score = recognize_vector(vec)
        if roll and score:
            # mark attendance with student's class
            conn = get_conn()
            try:
                rows, _ = exec_sql(conn, "SELECT class_name FROM students WHERE roll_number = " + placeholder(), (roll,))
                cls = rows[0][0] if rows else "Unknown"
                exec_sql(conn, "INSERT INTO attendance (student_roll_number, class_name, timestamp) VALUES (" + qmarks(3) + ")", (roll, cls, dt.datetime.now())); conn.commit()
            finally:
                conn.close()
            return jsonify(match={"roll_number": roll, "confidence": float(score)})
        return jsonify(match=None)
    finally:
        if temp_file:
            try: os.remove(temp_file)
            except Exception: pass

# ---------- Exports ----------
def rows_for_export(selected_date: Optional[str] = None):
    q = (
        "SELECT s.roll_number, s.name, a.class_name, a.timestamp "
        "FROM attendance a JOIN students s ON s.roll_number = a.student_roll_number"
    )
    params = []
    if selected_date:
        q += " WHERE DATE(a.timestamp) = " + placeholder()
        params.append(selected_date)
    q += " ORDER BY a.timestamp DESC"
    conn = get_conn()
    try:
        rows, _ = exec_sql(conn, q, tuple(params))
        return rows
    finally:
        conn.close()

@app.route("/export/csv")
@login_required
def export_csv():
    date_str = request.args.get("date")
    rows = rows_for_export(date_str)
    out = io.StringIO()
    w = csv.writer(out)
    w.writerow(["roll_number", "name", "class_name", "timestamp"])
    for r in rows:
        w.writerow([r[0], r[1], r[2], r[3]])
    out.seek(0)
    return Response(out.getvalue(), mimetype="text/csv", headers={"Content-Disposition": f"attachment; filename=attendance{('_'+date_str) if date_str else ''}.csv"})

@app.route("/export/xlsx")
@login_required
def export_xlsx():
    if openpyxl is None:
        return jsonify(error="openpyxl not available"), 503
    date_str = request.args.get("date")
    rows = rows_for_export(date_str)
    wb = openpyxl.Workbook()
    ws = wb.active
    ws.title = "Attendance"
    ws.append(["roll_number", "name", "class_name", "timestamp"])
    for r in rows:
        ws.append([r[0], r[1], r[2], r[3]])
    bio = io.BytesIO(); wb.save(bio); bio.seek(0)
    return send_file(bio, as_attachment=True, download_name=f"attendance{('_'+date_str) if date_str else ''}.xlsx", mimetype="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet")

@app.route("/export/pdf")
@login_required
def export_pdf():
    if canvas is None or A4 is None:
        return jsonify(error="reportlab not available"), 503
    date_str = request.args.get("date")
    rows = rows_for_export(date_str)
    bio = io.BytesIO()
    p = canvas.Canvas(bio, pagesize=A4)
    width, height = A4
    x, y = 40, height - 40
    p.setFont("Helvetica-Bold", 14); p.drawString(x, y, f"Attendance Report {('('+date_str+')') if date_str else ''}")
    y -= 30; p.setFont("Helvetica", 10)
    p.drawString(x, y, "roll_number"); p.drawString(x+120, y, "name"); p.drawString(x+270, y, "class_name"); p.drawString(x+400, y, "timestamp")
    y -= 18
    for r in rows:
        if y < 50:
            p.showPage(); y = height - 50
        p.drawString(x, y, str(r[0])); p.drawString(x+120, y, str(r[1])); p.drawString(x+270, y, str(r[2])); p.drawString(x+400, y, str(r[3]))
        y -= 16
    p.showPage(); p.save(); bio.seek(0)
    return send_file(bio, as_attachment=True, download_name=f"attendance{('_'+date_str) if date_str else ''}.pdf", mimetype="application/pdf")

# ---------- Utilities ----------
@app.route("/rebuild_embeddings")
@login_required
def rebuild_embeddings():
    build_student_embeddings()
    return jsonify(ok=True, loaded=len(student_embeddings))

# ---------- Main ----------
if __name__ == "__main__":
    setup_database()
    build_student_embeddings()
    if not student_embeddings:
        print("[INFO] No embeddings yet. Upload student images and call /rebuild_embeddings after.")
    port = int(os.getenv("PORT", "5001"))
    app.run(host="0.0.0.0", port=port, debug=True)
